* 一二集
** 添加控制，绑定代码文件为组件
** 设置默认 editor 为 vscode, install vscode 插件
- both browser and scripting editor can be setting in External Program
- Developer > VS Code Workflow to add tasks: Cmd + P > "task Cocos Compile"
** Cc.component start method get component.String.value
** cc.log web 模式下同 console.log
* 3集
** 面向组件编程：依然有类
** 车里的零件：参考 WinForm, 各种各种的预置组件，Text, Label, etc
** Cocos 里的精灵也可以安装不同的组件，碰撞组件，音频组件等，二次拼装，大大的简化了开发。
** 精灵首先是一个 Node, 可以进行 frame 的渲然。
** 角本也是一个组件
** 结点是有层级结构的：相对于父结点的坐标，类似于容器的概念
** This.node.children[0].opacity 设置（记得要挂载角本组件）。可以锁住。
* 4集：精灵组件的使用
** 图片精灵，单色精灵，default_sprite
** Atlas: 多张小图压缩到一起的大图，然后找坐标，宽高再裁剪。减少 IO 次数。工具： texture packer， unity 引擎的 NGUI
** Type: simple 修改尺寸整体拉伸
*** 九宮格：边角拉伸时不会变型
*** 平铺：适合背景图
*** 填充：类似遮罩，适合做血条
*** 网格：不知道，不太用
** Size mode:
*** Trim: 裁剪空白部分
*** Raw / custom
** Blend: 两个或以上的精灵混合效果
** Materials: 材质，一般不用管
** cc.resources loader 拿 spriteFrame
* 5课：角本组件的使用
** 3.0 以后放弃支持 Js, 只支持 Ts
** scripts > new JS/TS (recommended to use TS, the JS syntax is very weird)
** TS follows ES6.0 standard
** cc._decorator: 注解类型 - 修饰符: @ccclass 识别为一个具体的组件; @property 修饰为属性就右 Cocos Creator 的面板里就可以用了
** 自带的数据类型，就不用给 @property() 里传递参数，但 cc.Label 或 cc.Button 需要
** 生命周期函数: Life-Cycle Callbacks (7 methods)
*** onLoad(): when the component is loaded
*** start():
*** onEnable() / onDisable()
- this.target.active = false
- this.target.active = true
*** update(dt) / lateUpdate(dt)
- update: run when each frame is to be updated, dt is the interval between frames
- lateUpdate: run after update() is done (less used)
*** onDestroy()
** how to invoke Nodes in scripts:
- this.node: e.g. this.node.x / this.node.y += this.speed * dt
- this.node.children / this.node.getChildByName("name")
- cc.find("node1/node2")
- this.node.getParent()
- this.node.setParent(node0)
- this.node.removeAllChildren()
- this.node.removeChild(node0)
- this.node.removeFrameParent()
- this.getComponent(cc.Component)
- this.getComponentInChildren(cc.Label).string = "hello world"
* 6课：交互事件
** ctrl + shift + P can refresh the game application
** 封装了三种不同的事件：鼠标、键盘、触摸
** Like JS: addEventListener("mousedown", (event) => {})
** In Cocos2d:
- this.node.on(eventType: String, callback: function, target: any, useCapture: boolean)
- note that a node is not a DOM element, so JS addEventListener does not work directly
- can either be in start() or onLoad()
- this.node.on(cc.Node.EventType.MOUSE_DOWN, (event: cc.Event.EventMouse) => { cc.log(event.getLocation()); })
- event.getLocation() | event.getButton()
- cc.Event.EventMouse.BUTTON_LEFT
- this.node.off(cc.Node.EventType.MOUSE_DOWN)
- this.node.clear(): clear all events in relation to this node
** Keyboard Events: 全局事件
- cc.systemEvent.on(eventType, callback)
- cc.systemEvent.on(cc.SystemEvent.KEY_DOWN, (event: cc.Event.EventKeyboard) => {cc.log(event.keyCode)})
- cc.macro.KEY.a
** Touch Events: like MouseEvents, but no buttons
- event.getID() can get how many fingers used
- this.node.on(cc.Node.EventType.TOUCH_START, (event: cc.Event.EventTouch) => {})
- TOUCH_CANCEL
** 自定义事件
- cc.find("Player").emit("msg", arg1..arg5);
- 例如：微信小游戏工具中的通知：子弹打中敌机、要通机敌机：你被打中了，快减血
** 自定义事件另一种方式：分发事件流
  - let event = new cc.Event.EventCustom("myEvent", true);
  - event.setUserData("hello")
  - event.detail = { date: new Date(), text: "hello"}
  - cc.find("Player").dispatchEvent(event)
* Lession 7: collison check
** spriteA vs spriteB collison detection: add component - box / circle / polygon
** Editing the edges for the collison: use tag to identify each individual
** 碰撞检测的使用
- onCollisionEnter(other: cc.Collider, self: cc.Collider)
- onCollisionStay(other: cc.Collider, self: cc.Collider)
- onCollisionExit(other: cc.Collider, self: cc.Collider)
- cc.director.getCollisionManager().enabled = true // 开启碰撞管理器
- cc.director.getCollisionManager().enabledDebugDraw = true // 开启碰撞检测范围
- cc.director.getCollisionManager().enabledDrawBoundingBox = true // 开启碰撞检测边框
** 字弹飞出屏幕边界判断
- cc.view.getCanvasSize().height
** prefab: 预设体
- @property(cc.Prefab)
- setInterval(() => { cc.instantiate(this.bulletPrefab); bullet.x = this.node.x; bullet.y = this.node.y + this.node.height / 2; bullet.setParent(cc.director.getScene()); }, 1000)
- when bullets hit enemy: this.node.removeFromParent(); this.destory();
* Lession 8: 图片资源和音频资源
** Cocos Creator 3.0 supports jpg / png / bmp; 2.4 only supports jpg / png
** 所有要 cc.resources.load 动态加载的都需要放在 resources 文件夹下
** sample
- cc.resources.load("images/hero", cc.SpriteFrame, (error: Error, sf: cc.SpriteFrame) => { this.getComponent(cc.Sprite).spriteFrame = sf})
- this.node.with = 40;
- this.node.height = 40;
- SpriteAtlas (图集) 也是一样的用法；
** 音频资源: mp3, wav, ogg
- 其他组件 > AudioSource
- Clip 是音频文件，可以直接从资源管理器中拖过来
- Volume 是音量，0~1 之间
- Mute / Loop / Play on Load
- 可以创建一个单独的节点来负责播放音频
- play() / stop() / pause() / resume() / isPlaying
** AudioEngine: 适合控制多个音频的播放
- cc.resources.load("audio/bgm", cc.AudioClip, (error, clip) => { cc.audioEngine.playMusic(clip, true); })
- playEffect
- play
- cc.resources.loadDir
* Lession 9: 开发飞机大战
** Cocos 定时器
- schedule(callback: function, interval: number, repeat: number, delay: number)
** Demo
*** Player:
- onload: this.screenHeight = cc.view.getCanvasSize().height; this.screenWidth = cc.view.getCanvasSize().width
- start: this.isSelected = true or false base on he TOUCH_X events
- start: this.node.setPosition(e.getLocation()) base on TOUCH_MOVE events
*** Bullets:
- only need height, no need of width
- add an property to be speed = 200;
- update: this.node.y += this.speed * dt;
- update: if (this.node.y + this.node.height > this.screenHeight) this.node.removeFrameParent(true); this.destory();
- drag bullet node into resources to make it a prefab
- die(): need to call this method on Enemy by `other.getComponent(bullet)` in onCollisionEnter()
*** Player:
- @property(cc.Prefab) bulletPre = null (this shall be in Player.ts, not Bullet.ts)
- start: this.shedule(() => { this.shoot() }, shootInterval)
- shoot(): let bullet = cc.instantiate(this.bulletPre); bullet.x = this.node.x; bullet.y = this.node.y + this.node.height/2; bullet.setParent(cc.director.getScene)
- audio: cc.resources.load("audio/bullet", cc.AudioClip, (err, clip) => { cc.audioEngine.playEffect(clip, false) })
- add polygon collider
*** Enemy:
- add poygon collider
- start(): this.node.y = this.screenHeight + this.node.height
- start(): this.node.x = Math.random() * (this.screenWidth - this.node.width) + this.node.width / 2
- update(): this.node.y -= this.speed * dt
- onCollisionEnter(other: cc.Collider): if (other.tag == 9 && !this.isDead) { cc.find("Background").getComponent(Background).score++ }
  - else if (other.tag == 1 && !this.isDead) { cc.game.pause(); cc.audioEngine.stopAll(); alert("Game Over!"); }
- die():
  - cc.resources.load("audio/boom", cc.AudioClip, (err, clip) => {...} )
  - this.schedule(() => { cc.resources.load(`images/explosion${frameId}`, cc.SpriteFrame (error, sf) => {...})}, 0.1, 19, 0)

*** Background:
- @property(cc.Prefab) enemyPre
- start(): this.schedule(() => { let enemy = cc.instantiate(this.enemyPre) }, 1)
- onload(): cc.director.getCollisionManager().enabled = true;
* Lession 10: 向量(vector)在游戏中的使用
** 向量 vs 标量
** 游戏中的移动速度、加速度，物体的受力，给物体施加的冲量等
** 子弹斜飞速度
- Vx = V * cos0; Vy = V & sin0
** 弧度： 弧长 / 半径
- let rad = (this.node.angle + 90) * Math.PI / 180
- this.node.x += this.speed * dt * Math.cos(rad)
- this.node.y += this.speed * dt * Math.sin(rad)
** rotate the Axis
** 空节点用处之一：用来定位，比如子弹发射的位置
** Node 可以锁定以防止误操作
** Demo: 坦克大战
*** Tank
- onload: this.cannon = this.node.getChildByName("cannon")
  - this.bulletPre = this.cannon.getChildByName("")
- start: cc.systemEvent.on(cc.SystemEvent.EventType.KEY_DOWN)
  - this.node.angle = ??; this.node.y += this.speed;
  - cannon: this.cannon.angle += 5;
  - if (this.cannon.angle == 360): this.cannon.angle = 0
- fire(): cc.resources.load("audio/fire", cc.AudioClip, (err, clip) => { .. })
  - let bullet = cc.instantiate(this.bulletPre)
  - bullet.setPosition(this.bulletPos.convertToWorldSpaceAR(cc.Vec2.ZERO))
  - bullet.angle = this.node.angle + this.cannon.angle
  - bullet.setParent(cc.director.getScene());
  - if (!this.reloading)
  - setTimeout(() => { this.reloading = false })
- shotgun effect:
  - let bullets: cc.Node[] = new Array<cc.Node>();
  - for (let i = 0; i < bullets.length; i++)
  - bullets[i].angle = this.node.angle + this.cannon.angle + 30 - i * 30
  - bullets[i].setPosition(this.bulletPos.convertToWorldSpaceAR(cc.Vec2.ZERO))
* Lession 11-12: UI 组件
** 控件库 or 创建渲染组件或UI组件
** RichText: color / size / outline / b / i / u / on (e.g. click) / param / br /img
** Button: transition
- Click Events: 一般只有一个事件来处理就可以
** Layout 组件： 横向、纵向、网格
** EditBox: 常用在注册用户输入时；如果是微信小游戏，一般是获取信念授权
** Mask: 遮罩； can be inverted
** ScrollView: 滚动视图 > content > item - 可以用来作关卡的切换
** ProgressBar: 例如可以当血槽来用, 作格斗游戏的时候可以来用
** Slider: e.g. 音量大小
** Toggle: 单选框、复选框
** VideoPlayer
** WebView: 比较少用
